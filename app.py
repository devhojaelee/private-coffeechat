from flask import Flask, request, jsonify, render_template, redirect, url_for, session
from google.oauth2.credentials import Credentials
from googleapiclient.discovery import build
from google_auth_oauthlib.flow import Flow
from datetime import datetime, timedelta
from dateutil import parser
from pytz import timezone
from prometheus_flask_exporter import PrometheusMetrics  # ‚úÖ Ï∂îÍ∞Ä
from dotenv import load_dotenv
import pytz
import os
import sqlite3
import json
import sys
from calendar_utils import create_meet_event
from email_utils import send_meet_email

# ÏûÑÏãúÎ°ú http ÌóàÏö©
os.environ["OAUTHLIB_INSECURE_TRANSPORT"] = "1"
app = Flask(__name__)
metrics = PrometheusMetrics(app)  # ‚úÖ ÏÑ±Îä• Ï∏°Ï†ï ÌôúÏÑ±Ìôî
app.secret_key = 'super_secret_key'
app.permanent_session_lifetime = timedelta(minutes=10)  # ‚úÖ 10Î∂ÑÍ∞Ñ Ïú†Ìö®
korea_tz = timezone("Asia/Seoul")
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
DB_PATH = os.path.join(BASE_DIR, "user.db")
TOKEN_PATH = os.path.join(BASE_DIR, "token.json")
CLIENT_SECRET_FILE = os.path.join(BASE_DIR, "client_secret.json")
SCOPES = [
    "https://www.googleapis.com/auth/calendar.events",
    "https://www.googleapis.com/auth/calendar"
]

# ÌôòÍ≤ΩÎ≥ÄÏàò Í∏∞Î≥∏Í∞í ÏßÄÏ†ï
env_file = ".env.dev"
if len(sys.argv) > 1:
    env_file = sys.argv[1]

print(f"üì¶ Î°úÎî© ÌôòÍ≤Ω ÌååÏùº: {env_file}")
load_dotenv(dotenv_path=env_file)

PORT = int(os.getenv("FLASK_PORT", 9999))
DEBUG = os.getenv("FLASK_ENV") == "development"



def get_active_code():
    with sqlite3.connect(DB_PATH) as conn:
        c = conn.cursor()
        c.execute("SELECT code FROM invite_codes WHERE is_active = 1 ORDER BY created_at DESC LIMIT 1")
        row = c.fetchone()
        return row[0] if row else None

def set_active_code(new_code):
    with sqlite3.connect(DB_PATH) as conn:
        c = conn.cursor()
        # Î™®Îì† Í∏∞Ï°¥ ÏΩîÎìú ÎπÑÌôúÏÑ±Ìôî
        c.execute("UPDATE invite_codes SET is_active = 0")

        # ÏΩîÎìúÍ∞Ä Ïù¥ÎØ∏ ÏûàÏúºÎ©¥ is_activeÎßå 1Î°ú
        c.execute("SELECT id FROM invite_codes WHERE code = ?", (new_code,))
        if c.fetchone():
            c.execute("UPDATE invite_codes SET is_active = 1 WHERE code = ?", (new_code,))
        else:
            c.execute("INSERT INTO invite_codes (code, is_active, created_at) VALUES (?, 1, ?)", (new_code, datetime.now()))
        conn.commit()


def get_available_time_slots(token_path=TOKEN_PATH, year=None, month=None, view="month"):
    creds = Credentials.from_authorized_user_file(token_path)
    service = build("calendar", "v3", credentials=creds)

    tz = pytz.timezone('Asia/Seoul')
    now = datetime.now(tz)

    if view == "month":
        if year is None or month is None:
            year, month = now.year, now.month
        import calendar
        last_day = calendar.monthrange(year, month)[1]
        start_dt = tz.localize(datetime(year, month, 1, 0, 0, 0))
        end_dt = tz.localize(datetime(year, month, last_day, 23, 59, 59))
    else:
        start_dt = now - timedelta(days=now.weekday())
        start_dt = start_dt.replace(hour=0, minute=0, second=0, microsecond=0)
        end_dt = start_dt + timedelta(days=7)

    body = {
        "timeMin": start_dt.isoformat(),
        "timeMax": end_dt.isoformat(),
        "timeZone": "Asia/Seoul",
        "items": [{"id": "primary"}]
    }
    busy_times = service.freebusy().query(body=body).execute()
    busy_periods = busy_times['calendars']['primary']['busy']

    slots = []
    current = start_dt
    while current < end_dt:
        slot_end = current + timedelta(minutes=30)
        overlap = any(
            current < parser.isoparse(b['end']).astimezone(tz) and
            slot_end > parser.isoparse(b['start']).astimezone(tz)
            for b in busy_periods
        )
        if not overlap:
            slots.append({
                "start": current.strftime("%Y-%m-%dT%H:%M:%S"),
                "end": slot_end.strftime("%Y-%m-%dT%H:%M:%S"),
                "title": "Available"
            })
        current = slot_end

    return slots


def init_db():
    with sqlite3.connect(DB_PATH) as conn:
        c = conn.cursor()
        c.execute("""
            CREATE TABLE IF NOT EXISTS reservations (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                code TEXT, name TEXT, email TEXT, phone TEXT, purpose TEXT,
        """ + ",\n                ".join([f"slot_{i}_date TEXT, slot_{i}_time TEXT" for i in range(1, 17)]) + ",\n" +
        """
                created_at TEXT,
                approved_slot TEXT,
        """ + ",\n                ".join([f"slot_{i}_status TEXT DEFAULT 'pending'" for i in range(1, 17)]) + """
            )
        """)
        c.execute("""
            CREATE TABLE IF NOT EXISTS invite_codes (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                code TEXT UNIQUE,
                is_active INTEGER DEFAULT 1,
                created_at TEXT
            )
        """)
        c.execute("SELECT COUNT(*) FROM invite_codes")
        if c.fetchone()[0] == 0:
            c.execute("""
                INSERT INTO invite_codes (code, is_active, created_at)
                VALUES (?, 1, ?)
            """, ("code2025", datetime.now()))
        conn.commit()

@app.route("/")
def home():
    return render_template("index.html")

@app.route("/auth/google")
def auth_google():
    flow = Flow.from_client_secrets_file(
        CLIENT_SECRET_FILE,
        scopes=SCOPES,
        redirect_uri="http://localhost:33333/oauth2callback"
    )
    auth_url, _ = flow.authorization_url(prompt='consent', access_type='offline', include_granted_scopes='true')
    return redirect(auth_url)

@app.route("/oauth2callback")
def oauth2callback():
    flow = Flow.from_client_secrets_file(
        CLIENT_SECRET_FILE,
        scopes=SCOPES,
        redirect_uri="http://localhost:33333/oauth2callback"
    )
    flow.fetch_token(authorization_response=request.url)
    creds = flow.credentials
    with open(TOKEN_PATH, "w") as token_file:
        token_file.write(creds.to_json())
    return render_template("success.html")

@app.route("/api/available-slots", methods=["GET"])
def available_slots():
    year = request.args.get("year", type=int)
    month = request.args.get("month", type=int)
    view = request.args.get("view", default="month")

    try:
        slots = get_available_time_slots(year=year, month=month, view=view)
        return jsonify(slots)
    except Exception as e:
        return jsonify({"error": str(e)}), 500


@app.route("/admin-login", methods=["GET", "POST"])
def admin_login():
    if request.method == "POST":
        if request.form["password"] == "billyiscute":
            session["admin_logged_in"] = True
            return redirect("/admin")
        else:
            # ÎπÑÎ∞ÄÎ≤àÌò∏ ÌãÄÎ†∏ÏùÑ ÎïåÎèÑ Î©îÏãúÏßÄÏôÄ Ìï®Íªò Îã§Ïãú Î†åÎçîÎßÅ
            return render_template("admin_login.html", error="‚ùå ÎπÑÎ∞ÄÎ≤àÌò∏Í∞Ä Ïò¨Î∞îÎ•¥ÏßÄ ÏïäÏäµÎãàÎã§.")
    return render_template("admin_login.html")

@app.route("/admin-logout", methods=["POST"])
def admin_logout():
    session.pop("admin_logged_in", None)
    return redirect("/")


@app.route("/admin", methods=["GET", "POST"])
def admin():
    if not session.get("admin_logged_in"):
        return redirect("/admin-login")

    if request.method == "POST":
        if "approve_id" in request.form:
            res_id = int(request.form["approve_id"])
            with sqlite3.connect(DB_PATH) as conn:
                c = conn.cursor()
                c.execute("SELECT name, email, " + ", ".join([f"slot_{i}_date, slot_{i}_time" for i in range(1, 17)]) + " FROM reservations WHERE id = ?", (res_id,))
                row = c.fetchone()
                name, email = row[0], row[1]
                slots = [(row[i], row[i+1]) for i in range(2, len(row), 2) if row[i] and row[i+1]]
                if slots:
                    dt_slots = [datetime.strptime(f"{d} {t}", "%Y-%m-%d %H:%M") for d, t in slots]
                    dt_slots.sort()
                    start_dt = dt_slots[0]
                    end_dt = dt_slots[-1] + timedelta(minutes=30)
                    duration_minutes = int((end_dt - start_dt).total_seconds() // 60)
                    meet_link = create_meet_event(TOKEN_PATH, "hojaelee.aws@gmail.com", f"{name}ÎãòÍ≥ºÏùò ÎØ∏ÌåÖ", start_dt, duration_minutes)
                    send_meet_email(email, name, f"{start_dt.strftime('%Y-%m-%d %H:%M')} ~ {end_dt.strftime('%H:%M')}", meet_link)

                    c.execute("UPDATE reservations SET approved_slot = ? WHERE id = ?", (f"{start_dt.strftime('%Y-%m-%d %H:%M')}", res_id))
                    for i, (slot_date, slot_time) in enumerate(slots):
                        c.execute(f"UPDATE reservations SET slot_{i+1}_status = 'approved' WHERE id = ?", (res_id,))
                conn.commit()

        elif "reject_id" in request.form:
            res_id = int(request.form["reject_id"])
            with sqlite3.connect(DB_PATH) as conn:
                c = conn.cursor()
                for i in range(1, 17):
                    c.execute(f"UPDATE reservations SET slot_{i}_status = 'rejected' WHERE id = ?", (res_id,))
                c.execute("UPDATE reservations SET approved_slot = NULL WHERE id = ?", (res_id,))
                conn.commit()

        elif "remove_id" in request.form:
            delete_id = int(request.form["remove_id"])
            with sqlite3.connect(DB_PATH) as conn:
                c = conn.cursor()
                c.execute("DELETE FROM reservations WHERE id = ?", (delete_id,))
                conn.commit()

    with sqlite3.connect(DB_PATH) as conn:
        c = conn.cursor()
        slot_fields = []
        for i in range(1, 17):
            slot_fields.append(f"slot_{i}_date")
            slot_fields.append(f"slot_{i}_time")

        fields = ["id", "code", "name", "email", "phone", "purpose"] + slot_fields + ["created_at", "approved_slot"]
        c.execute(f"SELECT {', '.join(fields)} FROM reservations ORDER BY created_at DESC")
        rows = c.fetchall()

        cleaned_rows = []
    for row in rows:
        meta = row[:6]
        slot_data = row[6:38]
        slots = []
        for i in range(0, 32, 2):
            date, time = slot_data[i], slot_data[i+1]
            if date and time:
                slots.append(f"{date} {time}")
        created_at = row[38]
        approved_slot = row[39]

        # ‚úÖ ÏÉÅÌÉú ÌåêÎã® Î°úÏßÅ Ï∂îÍ∞Ä
        c.execute("SELECT " + ", ".join([f"slot_{i}_status" for i in range(1, 17)]) + " FROM reservations WHERE id = ?", (row[0],))
        status_row = c.fetchone()
        slot_statuses = [s for s in status_row if s]

        non_empty_statuses = [s for s in slot_statuses if s and s.strip() != ""]

        if approved_slot:
            status_label = "ÏäπÏù∏Îê®"
        elif non_empty_statuses and all(s == "rejected" for s in non_empty_statuses):
            status_label = "Í±∞Ï†àÎê®"
        else:
            status_label = "ÎåÄÍ∏∞ Ï§ë"


        # ‚úÖ ÎßàÏßÄÎßâÏóê status_label Ï∂îÍ∞ÄÌï¥ÏÑú ÌÖúÌîåÎ¶øÏóê ÎÑòÍπÄ
        cleaned_rows.append(tuple(meta) + (slots,) + (created_at, approved_slot, status_label))

    rows = cleaned_rows
    for row in cleaned_rows:
        print("üü¶ ÏòàÏïΩ ID:", row[0], "| ÏÉÅÌÉú:", row[-1])



    return render_template("admin.html", reservations=rows, active_code=get_active_code())

@app.route("/invite", methods=["GET", "POST"])
def invite():
    if request.method == "POST":
        code = request.form.get("code")
        if code == get_active_code():
            session["invited"] = True  # ‚úÖ ÏÑ∏ÏÖò ÏÑ§Ï†ï
            return redirect(url_for("calendar_view"))
        return render_template("invalid_code.html")
    return render_template("calendar.html")


@app.route("/reservation", methods=["POST"])
def reservation():
    raw = request.form.get("selected_slots", "")
    selected_slots = raw.split(",") if raw else []
    return render_template("reservation.html", selected_slots=selected_slots)

@app.route("/submit", methods=["POST"])
def submit():
    name = request.form.get("name")
    email = request.form.get("email")
    phone = request.form.get("phone")
    purpose = request.form.get("purpose")
    selected_slots = request.form.getlist("selected_slots")
    session["invited"] = True  # ‚úÖ ÏÑ∏ÏÖò Ï∂îÍ∞Ä
    # ‚úÖ ÏÑúÎ≤Ñ Ï∏° Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨
    import re
    name_regex = re.compile(r'^[Í∞Ä-Ìû£a-zA-Z\s]+$')
    phone_regex = re.compile(r'^[0-9/\-]+$')
    email_regex = re.compile(r'^[\w\.-]+@[\w\.-]+\.\w+$')

    errors = []
    if not name or not name_regex.match(name):
        errors.append("Ïù¥Î¶ÑÏùÄ ÌïúÍ∏Ä, ÏòÅÏñ¥, ÎùÑÏñ¥Ïì∞Í∏∞Îßå ÏûÖÎ†• Í∞ÄÎä•Ìï©ÎãàÎã§.")
    if not email or not email_regex.match(email):
        errors.append("Ïù¥Î©îÏùº ÌòïÏãùÏù¥ Ïò¨Î∞îÎ•¥ÏßÄ ÏïäÏäµÎãàÎã§.")
    if not phone or not phone_regex.match(phone):
        errors.append("Ï†ÑÌôîÎ≤àÌò∏Îäî Ïà´Ïûê, - Îßå ÏÇ¨Ïö©Ìï† Ïàò ÏûàÏäµÎãàÎã§.")
    if not purpose or len(purpose.strip()) < 1:
        errors.append("Ïö©Í±¥ÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.")
    if not selected_slots:
        errors.append("ÏòàÏïΩ ÏãúÍ∞ÑÎåÄÎ•º 1Í∞ú Ïù¥ÏÉÅ ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.")

    if errors:
        return render_template("reservation.html", selected_slots=selected_slots, error_msg=" / ".join(errors))

    # ‚úÖ Ïä¨Î°Ø ÌååÏã±
    slot_dates = [""] * 16
    slot_times = [""] * 16
    for i, slot in enumerate(selected_slots):
        if i < 16:
            try:
            # ‚úÖ ÌÉÄÏûÑÏ°¥ Ìè¨Ìï®Îêú ISO Ìè¨Îß∑ Î¨∏ÏûêÏó¥ Ï≤òÎ¶¨
                dt = datetime.strptime(slot.strip(), "%Y-%m-%dT%H:%M:%S")
                dt = korea_tz.localize(dt)  # naive ‚Üí awareÎ°ú ÎßåÎì§Ïñ¥Ï§å
                slot_dates[i] = dt.strftime("%Y-%m-%d")
                slot_times[i] = dt.strftime("%H:%M")
            except Exception as e:
                print(f"‚ùå Ïä¨Î°Ø ÌååÏã± Ïã§Ìå®: {slot} ‚Üí {e}")

    with sqlite3.connect(DB_PATH) as conn:
        c = conn.cursor()
        c.execute(f"""
            INSERT INTO reservations (
                code, name, email, phone, purpose,
                {', '.join([f"slot_{i}_date" for i in range(1, 17)])},
                {', '.join([f"slot_{i}_time" for i in range(1, 17)])},
                created_at
            ) VALUES (
                ?, ?, ?, ?, ?,
                {', '.join(['?'] * 16)},
                {', '.join(['?'] * 16)},
                ?
            )
        """, (
            "code2025", name, email, phone, purpose,
            *slot_dates,
            *slot_times,
            datetime.now()
        ))
        res_id = c.lastrowid

    return render_template("submit_success.html", name=name, selected_slots=selected_slots, res_id=res_id, phone=phone)


@app.route("/calendar")
def calendar_view():
    if not session.get("invited"):
        return redirect("/")  # Ï¥àÎåÄÏΩîÎìú ÌéòÏù¥ÏßÄÎ°ú Î¶¨ÎîîÎ†âÌä∏
    return render_template("calendar.html")

@app.route("/status/<int:res_id>")
def status(res_id):
    # ‚úÖ Ï†ÑÌôîÎ≤àÌò∏ Í∏∞Î∞ò Ï°∞ÌöåÏùº Í≤ΩÏö∞Ïóî ÏÑ∏ÏÖòÏóê Ï†ÄÏû•Îêú res_idÎßå ÌôïÏù∏
    if session.get("status_res_id") != res_id:
        return redirect("/")

    with sqlite3.connect(DB_PATH) as conn:
        c = conn.cursor()

        # Ïù¥Î¶Ñ ÌôïÏù∏
        c.execute("SELECT name FROM reservations WHERE id = ?", (res_id,))
        row = c.fetchone()
        if not row:
            return render_template("status.html", error="Ìï¥Îãπ ÏòàÏïΩ Î≤àÌò∏Îäî Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏäµÎãàÎã§.")
        name = row[0]

        # Ïä¨Î°Ø ÏÉÅÌÉú ÌôïÏù∏
        statuses = []
        approved_slots = []
        for i in range(1, 17):
            c.execute(f"SELECT slot_{i}_date, slot_{i}_time, slot_{i}_status FROM reservations WHERE id = ?", (res_id,))
            r = c.fetchone()
            if r and r[0] and r[1] and r[2]:
                statuses.append(r[2])
                if r[2] == "approved":
                    try:
                        dt = datetime.strptime(f"{r[0]} {r[1]}", "%Y-%m-%d %H:%M")
                        approved_slots.append(dt)
                    except Exception as e:
                        print(f"‚ö†Ô∏è ÏãúÍ∞Ñ ÌååÏã± Ïã§Ìå®: {r} ‚Üí {e}")

    # ÏÉÅÌÉú Î©îÏãúÏßÄ Í≤∞Ï†ï
    if any(s == "approved" for s in statuses):
        approved_slots.sort()
        start_dt = approved_slots[0]
        end_dt = approved_slots[-1] + timedelta(minutes=30)
        status_msg = f"""
            ‚úÖ ÏòàÏïΩÏù¥ ÏäπÏù∏ÎêòÏóàÏäµÎãàÎã§!<br>
            ÏäπÏù∏Îêú ÏãúÍ∞Ñ: <strong>{start_dt.strftime('%Y-%m-%d %H:%M')} ~ {end_dt.strftime('%H:%M')}</strong>
        """
    elif all(s == "rejected" for s in statuses if s):
        status_msg = "‚ùå ÏòàÏïΩÏù¥ Í±∞Ï†àÎêòÏóàÏäµÎãàÎã§."
    else:
        status_msg = "‚è≥ ÏòàÏïΩÏù¥ ÏïÑÏßÅ ÏäπÏù∏ÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. ÎåÄÍ∏∞ Ï§ëÏûÖÎãàÎã§."

    return render_template("status.html", name=name, res_id=res_id, status_msg=status_msg)



@app.route("/status", methods=["POST", "GET"])
def status_form():
    phone = request.form.get("phone")
    if not phone:
        return "<h2 class='text-danger text-center'>Ï†ÑÌôîÎ≤àÌò∏Î•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.</h2>"

    with sqlite3.connect(DB_PATH) as conn:
        c = conn.cursor()
        c.execute("SELECT id FROM reservations WHERE phone = ?", (phone,))
        result = c.fetchone()
    
    if result:
        res_id = result[0]
        session["status_res_id"] = res_id  # ‚úÖ ÏÑ∏ÏÖòÏóê Ï†ÄÏû•
        return redirect(url_for("status", res_id=res_id))  # ‚úÖ Í∑∏ÎåÄÎ°ú ÏÇ¨Ïö© Í∞ÄÎä•
    else:
        return render_template("status.html", error="Ìï¥Îãπ Ï†ÑÌôîÎ≤àÌò∏Î°ú Îì±Î°ùÎêú ÏòàÏïΩÏù¥ ÏóÜÏäµÎãàÎã§.")

@app.route("/status-check", methods=["GET"])
def status_check_page():
    return render_template("status.html")

@app.template_filter('datetime')
def parse_datetime(value, format='%Y-%m-%dT%H:%M'):
    return datetime.strptime(value, format)

@app.template_filter('add_duration')
def add_duration(value, minutes):
    return (value + timedelta(minutes=minutes)).strftime('%H:%M')



if __name__ == "__main__":
    init_db()
    set_active_code("code2025")
    app.run(debug=DEBUG, host="0.0.0.0", port=PORT)
